{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "09700b7d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from tqdm import tqdm\n",
    "import networkx as nx"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "9a57cb04",
   "metadata": {},
   "outputs": [],
   "source": [
    "NUM_STREAM_SPEC = list(range(8, 189, 10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "d9fdc2c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "PERIOD_SPEC = [1, 2, 3, 4, 5, 6]\n",
    "def period_spec(opt):\n",
    "    if opt == 1:\n",
    "        return 2_000_000\n",
    "    if opt == 2:\n",
    "        return 400_000\n",
    "    if opt == 3:\n",
    "        return int(np.random.choice([500_000, 1_000_000, 2_000_000, 4_000_000]))\n",
    "    if opt == 4:\n",
    "        return int(np.random.choice([100_000, 200_000, 400_000, 800_000]))\n",
    "    if opt == 5:\n",
    "        return int(np.random.choice([250_000, 500_000, 1_250_000, 2_500_000, 4_000_000]))\n",
    "    if opt == 6:\n",
    "        return int(np.random.choice([50_000, 100_000, 250_000, 500_000, 800_000]))\n",
    "    assert False, \"Invalid option\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "2d0937a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "SIZE_SPEC = [1,2,3,4,5]\n",
    "def data_spec(opt):\n",
    "    if opt == 1:\n",
    "        return 50\n",
    "    if opt == 2:\n",
    "        return int(np.random.choice(range(100, 501, 100)))\n",
    "    if opt == 3:\n",
    "        return int(np.random.choice(range(200, 1501, 100)))\n",
    "    if opt == 4:\n",
    "        return int(np.random.choice(range(500, 4501, 100)))\n",
    "    if opt == 5:\n",
    "        return int(np.random.choice(range(1500, 4501, 100)))\n",
    "    assert False, \"Invalid option\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "93a9fce1",
   "metadata": {},
   "outputs": [],
   "source": [
    "DEADLINE_SPEC = [1,2,3,4,5]\n",
    "def deadline_spec(opt):\n",
    "    if opt == 1:\n",
    "        assert False\n",
    "    if opt == 2:\n",
    "        return int(np.random.choice([100_000, 200_000, 400_000, 800_000, 1_600_000]))\n",
    "    if opt == 3:\n",
    "        return int(np.random.choice([10_000, 25_000, 50_000, 100_000, 200_000, 400_000]))\n",
    "    if opt == 4:\n",
    "        return int(np.random.choice([0, 10_000, 20_000, 25_000, 50_000]))\n",
    "    if opt == 5:\n",
    "        return 0\n",
    "    assert False, \"Invalid option\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "9aa71543",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Configurations\n",
    "\n",
    "## Network setting\n",
    "\n",
    "\n",
    "NUM_ES = 8\n",
    "NUM_SW = 8\n",
    "NUM_NODE = NUM_ES + NUM_SW\n",
    "NUM_PORT = 4\n",
    "NUM_QUEUES = 8\n",
    "DATA_RATE = 1\n",
    "ERROR = 1_000\n",
    "STRUCTURE = 1     ## 0:LINEAR, 1:RING, 2:MESH, 3:INDUSTRIAL\n",
    "\n",
    "MAX_FLOW = 256\n",
    "\n",
    "\n",
    "# ## Task setting\n",
    "\n",
    "## Workload setting\n",
    "# HEADER = 'utilization'\n",
    "# MAX_FLOW, STEP = 1024, 2\n",
    "# PERIOD = [50_000, 100_000, 200_000, 400_000]\n",
    "# SIZE = [50, 100, 500, 750, 1000, 1500, 4500]\n",
    "# DEADLINE = [10_000, 25_000, 50_000, 75_000, 100_000, 200_000, 400_000, 600_000,\n",
    "# 800_000, 1_000_000]\n",
    "\n",
    "## Number of streams\n",
    "# HEADER = 'stream'\n",
    "# MAX_FLOW, STEP = 189, 10\n",
    "# PERIOD = [50_000, 100_000, 200_000, 400_000]\n",
    "# SIZE = [50, 100, 500, 750, 1000, 1500, 4500]\n",
    "# DEADLINE = [10_000, 25_000, 50_000, 75_000, 100_000, 200_000, 400_000, 600_000,\n",
    "# 800_000, 1_000_000]\n",
    "\n",
    "# # ## -------- GENERATE A NORMAL DATASET -------------\n",
    "# HEADER = 'normal'\n",
    "# MAX_FLOW, STEP = 1024, 1\n",
    "# ## 1 Âµs to 1 ms from INDUSTRY PROFILE\n",
    "# PERIOD = [50_000, 100_000, 250_000, 600_000, 800_000, 1_000_000]\n",
    "# SIZE = [50, 100, 500, 1000, 1500, 4500]\n",
    "# DEADLINE = [10_000, 25_000, 50_000, 75_000, 100_000, 200_000, 400_000, 600_000,\n",
    "# 800_000, 1_000_000]\n",
    "\n",
    "## -------- GENERATE A SINGLE DATASET -------------\n",
    "# HEADER = 'single'\n",
    "# MAX_FLOW, STEP = 1024, 1\n",
    "# PERIOD = [1_000_000]\n",
    "# SIZE = [50, 100, 500, 1000, 1500, 4500]\n",
    "# DEADLINE = [10_000, 25_000, 50_000, 75_000, 100_000, 200_000, 400_000, 600_000,\n",
    "# 800_000, 1_000_000]\n",
    "\n",
    "## Global setting\n",
    "GRANULARITY = 100"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4287c384",
   "metadata": {},
   "source": [
    "## Generate Network configuration file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "5a865db5",
   "metadata": {},
   "outputs": [],
   "source": [
    "def network(topo, header):\n",
    "    net = np.zeros(shape = (NUM_NODE, NUM_NODE))\n",
    "\n",
    "    ## Liner topology\n",
    "    if topo >= 0:\n",
    "        ## Connect line\n",
    "        for i in range(0, NUM_SW - 1):\n",
    "            net[i, i+1] = 1\n",
    "            net[i+1, i] = 1\n",
    "        ## Connect ring\n",
    "        if topo >= 1:\n",
    "            net[0, NUM_SW - 1] = 1\n",
    "            net[NUM_SW - 1, 0] = 1\n",
    "        if topo >= 2:\n",
    "            for i in range(0, NUM_SW // 2):\n",
    "                net[i, NUM_SW - i - 1] = 1\n",
    "                net[NUM_SW - i - 1, i] = 1\n",
    "\n",
    "    result = []\n",
    "    for i in range(NUM_SW):\n",
    "        for k in range(NUM_SW):\n",
    "            if net[i][k]:\n",
    "                link = []\n",
    "                link.append((i, k))\n",
    "                link.append(NUM_QUEUES)\n",
    "                link.append(DATA_RATE)\n",
    "                link.append(ERROR)\n",
    "                link.append(0)\n",
    "                result.append(link)\n",
    "                \n",
    "        net[i+NUM_SW, i] = 1\n",
    "        link = []\n",
    "        link.append((i + NUM_SW, i))\n",
    "        link.append(NUM_QUEUES)\n",
    "        link.append(DATA_RATE)\n",
    "        link.append(ERROR)\n",
    "        link.append(0)\n",
    "        result.append(link)\n",
    "        \n",
    "        net[i, i+NUM_SW] = 1\n",
    "        link = []\n",
    "        link.append((i, i + NUM_SW))\n",
    "        link.append(NUM_QUEUES)\n",
    "        link.append(DATA_RATE)\n",
    "        link.append(ERROR)\n",
    "        link.append(0)\n",
    "        result.append(link)\n",
    "\n",
    "    result = pd.DataFrame(result, columns=['link','q_num','rate','t_proc','t_prop'])\n",
    "    result.to_csv(header + '_topology.csv', index=False)\n",
    "    \n",
    "    return net"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "932e4ba1",
   "metadata": {},
   "outputs": [],
   "source": [
    "def line(num_sw, num_queue, data_rate):\n",
    "    num_node = num_sw * 2\n",
    "\n",
    "    header = 'line'\n",
    "    net = np.zeros(shape = (num_node, num_node))\n",
    "\n",
    "    ## Connect the line\n",
    "    for i in range(0, num_sw - 1):\n",
    "        net[i, i+1] = 1\n",
    "        net[i+1, i] = 1\n",
    "    ## Connect the switch and the end-station\n",
    "    for i in range(num_sw):\n",
    "        net[i+num_sw, i] = 1\n",
    "        net[i, i+num_sw] = 1\n",
    "\n",
    "    result = []\n",
    "    for i in range(num_node):\n",
    "        for j in range(num_node):\n",
    "            if net[i][j]:\n",
    "                link = []\n",
    "                link.append((i, j))\n",
    "                link.append(num_queue)\n",
    "                link.append(data_rate)\n",
    "                link.append(ERROR)\n",
    "                link.append(0)\n",
    "                result.append(link)\n",
    "\n",
    "    result = pd.DataFrame(result, columns=['link','q_num','rate','t_proc','t_prop'])\n",
    "    result.to_csv(header + '_topology.csv', index=False)\n",
    "    return net"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a2dbeb92",
   "metadata": {},
   "outputs": [],
   "source": [
    "def topo(graph, header):\n",
    "    result = []\n",
    "    deadline_opt = np.random.choice(DEADLINE_SPEC)\n",
    "    period_opt = np.random.choice(PERIOD_SPEC)\n",
    "    size_opt = np.random.choice(SIZE_SPEC)\n",
    "    num_thres = np.random.choice(NUM_STREAM_SPEC)\n",
    "\n",
    "    i = 0\n",
    "    uti = 0\n",
    "    uti_ports = np.zeros(NUM_ES)\n",
    "    while True:\n",
    "        if i >= num_thres:\n",
    "            result = pd.DataFrame(result, columns = ['id','src','dst','size','period','deadline','jitter'])\n",
    "            result.to_csv(header + '.csv', index=False)\n",
    "            return\n",
    "\n",
    "        availble_es = np.array([x for x in range(NUM_ES)])\n",
    "        start = int(np.random.choice(availble_es + NUM_SW))\n",
    "        end = int(np.random.choice([x for x in range(NUM_SW, NUM_SW + NUM_ES) if x != start]))\n",
    "        path = bfs_paths(graph, start, end)\n",
    "\n",
    "        period = period_spec(period_opt)\n",
    "        size = data_spec(size_opt)\n",
    "        deadline = (len(path) - 1) * (ERROR + size * 8) + deadline_spec(deadline_opt) if deadline_opt > 1 else period\n",
    "        if deadline <= period:\n",
    "            result.append([i, start, [end], size, period, deadline, deadline])\n",
    "            uti += size * 8 / period\n",
    "            uti_ports[start - NUM_SW] += size * 8 / period\n",
    "            i += 1\n",
    "        else:\n",
    "            continue\n",
    "        \n",
    "        \n",
    "\n",
    "header = 'line'\n",
    "for num_sw in range(8, 98, 10):\n",
    "    net = line(num_sw, 8, 1)\n",
    "    for ins in tqdm(range(512)):\n",
    "        graph = nx.from_numpy_matrix(net)\n",
    "        topo(graph, header + '/' + header + '_' + str(num_sw) + '_' + str(ins))\n",
    "    \n",
    "\n",
    "header = 'ring'\n",
    "for num_sw in range(8, 98, 10):\n",
    "    net = ring(num_sw, 8, 1)\n",
    "    for ins in tqdm(range(512)):\n",
    "        graph = nx.from_numpy_matrix(net)\n",
    "        topo(graph, header + '/' + header + '_' + str(num_sw) + '_' + str(ins))\n",
    "\n",
    "header = 'tree'\n",
    "for num_sw in range(8, 98, 10):\n",
    "    net = tree(num_sw, 8, 1)\n",
    "    for ins in tqdm(range(512)):\n",
    "        graph = nx.from_numpy_matrix(net)\n",
    "        topo(graph, header + '/' + header + '_' + str(num_sw) + '_' + str(ins))\n",
    "        \n",
    "header = 'mesh'\n",
    "for num_sw in range(8, 98, 10):\n",
    "    net = mesh(num_sw, 8, 1)\n",
    "    for ins in tqdm(range(512)):\n",
    "        graph = nx.from_numpy_matrix(net)\n",
    "        topo(graph, header + '/' + header + '_' + str(num_sw) + '_' + str(ins))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  },
  "vscode": {
   "interpreter": {
    "hash": "e7370f93d1d0cde622a1f8e1c04877d8463912d04d973331ad4851f04de6915a"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
